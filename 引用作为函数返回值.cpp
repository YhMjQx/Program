#include<iostream>
using namespace std;
//引用访问一个变量是直接访问，而指针是间接访问，而且引用一经初始化就不能再引用其他变量，但指针可以
//引用传递，实参初始化形参不需要开辟空间
//指针传递，本质还是值传递，实参初始化形参时会分配空间，分配的是指针的大小，如果要改变指针那么可以用二级指针或者指针引用（*&）
int arr[] = { 0, 1, 2, 3, 4 };
int& index(int i){
	//在函数返回的时候进行引用初始化
	return arr[i];
}
//如果函数返回的是对函数内部局部变量的引用的话会怎么样呢？：
int& add(int a, int b){
	int sum = a + b;
	return sum;
}
int main(){
	//函数返回引用的一个主要目的就是将函数放在赋值运算符的左边
	//但是一定要注意的是！！！不能返回对函数内部局部变量的引用(局部变量出函数就销毁了)
	cout << "index(3)=" << index(3) << endl;
	index(3) = 39;//int& arr[3] = 39;
	//引用作为函数返回值，使得函数可以放在赋值运算符的左边
	cout << "index(3)=" << index(3) << endl;
	//本来index(3)应该是arr[3]的，也就是3
	//函数返回引用，引用在函数返回的时候初始化
	

	//我们来看函数返回的是内部局部变量的话会怎样
	int n = add(3, 9);
	//这里的意思是将引用到的结果赋值给n，所以不论n什么时候输出都不会有错
	int& m = add(4, 5);
	//但是这里的m是引用，引用不是变量，它没有自己的独立空间的
	//引用依赖于它所引用的值，，如果所引用的变量的生命周期结束了
	//那么这就是一个无效的引用，则m的值就是不确定的

	//那为什么在下面我们可以看到，如果先输出m就没事，但后输出m变成了随机值了呢
	//大概情况如下：
	//如果放在第一次输出的话，那么函数内部的sum是第一次被引用，其虽然地址
	//已经被销毁了，但实际上数据还没有被销毁，那么第一次引用的时候就可以引用
	//到sum的数据，但如果先输出n，再输出m的话，这种情况就有可能变成，sum的
	//数据先被输出n的这句代码所覆盖，然后引用就引用不到了
	//以上均是学习后的个人理解，不一定正确
	cout << "m=" << m << endl;//正确
	cout << "n=" << n << endl;//正确
	cout << "m=" << m << endl;//错误

	return 0;
}