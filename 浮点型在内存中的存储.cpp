#include<stdio.h>
#include<limits.h>//整形数据文件
#include<float.h>//浮点型数据文件
/*
以下具体内容见鹏哥C语言第29节课
IEEE 754 浮点型数据的存储
如果能把一个浮点数写作(-1)^S * M * 2^E,则，将浮点数往内存中存储的时候，只需用将S M E三个数存进去就行了
对于32个bit位的浮点数，有以下存储方式
 |        |                       |
S第一个bit位，符号位
E中间8个bit位，指数E
M后面23个bit位，有效数字M
而对于64个bit位的浮点数S E M就分别对应1 11 52个bit位
而且IEEE 754规定，M存储中，不存小数点前面的1，只存小数点后面的数据
规定E为无符号数，则E若为8bit位（0-255）,若E为11bit位（0-2047），但科学计数法中存在负数。那么具体是什么情况呢
规定8bit的E存储时用真实值加上127再存进内存，11bit位的E先用真实值加上1023再存进内存
同时，指数E从内存中取出来的时候又分为三种情况：
1.E不为全0或不为全1――取出时E=E的存储值-127，例如E的真实值为2的话，存储值真实值+127就为129
2.E为全0――此时E的真实值为-127，还原时M前面的1不用还原，同时规定指数就为1-127=-126
3.E为全1――此时E的真实值为255-127=128，表示的是正负无穷大的数字
*/
int main()
{
	int n = 9;
	//00000000000000000000000000001001	补码
	//0 00000000 00000000000000000001001
	//S E        M
	//(-1)^0 * 0.00000000000000000001001 * 2^-126
	float* pFloat = (float*)&n;
	printf("n的值为:%d\n", n);
	printf("*pFloat的值为:%f\n", *pFloat);

	*pFloat = 9.0;
	//1001.0
	//(-1)^0 * 1.001 * 2^3
	//则存时	0 10000010 00100000000000000000000
	//			S E(3+127) M(小数点后再补0)
	printf("num的值为:%d\n", n);
	//由于这里打印的是整形的数字，所以按内存中的补码打印，即从内存中的二进制补码转化为十进制，再打印
	//即01000001000100000000000000000000转化为1091567616
	printf("*pFloat的值为:%f\n", *pFloat);
	return 0;
}