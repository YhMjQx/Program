#include<stdio.h>
struct s1
{
	char a1;
	int b1;
	char a2;
};
//s1的内存对齐：
//|a1-0|	 |	  |	  |b1   |	  |	  |	  |a2	  |	  |	  |	  |
//该结构体的最大对齐数为4,12为4的倍数，于是最后需要再浪费3个字节凑成12
struct s2
{
	char a1;
	char a2;
	int b1;
};
//s2的内存对齐：
//|a1	|a2  |	  |	   |b1  |	|	|	|
//该结构体最大对齐数为4刚好8是4的倍数
struct s3
{
	char a1;
	struct s2 c;//要想结构体嵌套有用的话，这里一定要创建结构体变量
	int b1;
};
int main()
{
	//结构体内存对齐基本准则：
	//1.第一个成员变量放在与结构体起始位置偏移量为0出的位置
	//2.其他成员变量要放在其对齐数的整数倍的地址处
	//对齐数=成员变量与编译器自身默认对齐数中的较小值（VS默认对齐数为8，gcc和linux没有默认对齐数）
	//3.结构体总大小为成员变量最大对齐数的整数倍
	//4.如果嵌套了结构体的情况，嵌套的结构体对齐到自己最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数的整数倍
	struct s1 a = { 0 };
	printf("%d\n", sizeof(s1));
	struct s2 b = { 0 };
	printf("%d\n", sizeof(s2));
	printf("%d\n", sizeof(s3));
	//所以在设计结构体的时候，尽量让内存小的变量放在一起
	return 0;
}
//为什么会存在内存对齐：
//1.平台原因：不是所有硬件平台都能访问任意地址上的任意数据；
//			某些硬件平台只能在某些特定大小的地址处读取某些特定类型的数据，否则抛出硬件异常
//2.性能原因：数据结构（尤其是栈）应该尽可能的在自然边界上对齐。原因在于为了访问未对齐的内存
//			处理器需要做两次内存访问，而对齐内存只需要一次访问便可读取数据
//总的来说，结构体的内存对齐就是那空间来换取时间的做法