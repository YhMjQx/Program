#include<stdio.h>
//位段的内存分配：
//1.位段的成员可以是int，unsigned int，signed int或者是char（属于整形类型的家族）类型
//2.位段的空间上是按照4个字节（int）或者1个字节（char）的空间来开辟的
//3.位段涉及很多不确定因素，位段是不跨平台的，注重可移植的程序应该避免位段

//位段的跨平台问题：
//1.int位段被当成有符号数还是无符号数是不确定的
//2.位段中最大位的数目不确定，（16位机器最大16,32位机器最大32，写成27,16位机器出问题但32位机器不会）
//3.位段中的成员在内存中分配内存，是从左向右还是从右向左尚未定义
//4.当一个结构包含两个位段，第二个位段成员比较大，无法容纳于第一个位段剩余的位时，是舍弃剩余的位还是利用，这也是不确定的
struct S
{
	int a : 2;
	int b : 5;
	int c : 10;
	int d : 30;
};
//后边的数字表示每个变量所需比特位的大小，且后边的数字不能大于32
//首先一看这是个位段类型，再一看大小，先分配4个字节大小的空间也就是32个bit位，a占用2个bit,b占用5个bit，c占用10个bit
//现在已经占用了17个bit，还剩下15个bit，但d需要30个bit，剩下的15个bit位并不够用，于是在VS2013这个编译器当中，
//将剩下的这15个bit位的空间丢掉，然后在开辟一个4个字节（32bit）的空间，用d占用30个bit剩下的2bit再次丢掉
int main()
{
	//位段也是一种结构体类似的类型，不过和结构体有点区别，位段就是为了节省空间的
	//位段的成员一般是int，unsigned int，signed int，char
	//主要是相同的类型，就算是有不同的类型在一起,那他们的大小也必须是比较相近的
	//位段的成员名后会有一个:（冒号）和一个数字。int _a:2;	int _b:5;（_）可以不用写
	struct S s;
	s.a = 10;
	printf("%d\n", s.a);//-2
	//我在这里给赋值为10，但结果却是-2，由此可知，位段的确能极大程度上节约空间，这样的话，我所赋的值就必须在给定的bit范围当中
	printf("%d\n", sizeof(s));//8个字节
	return 0;
}