#include<stdio.h>
struct Test
{
	int Num;
	char *pcName;
	short sDate;
	char cha[2];
	short sBa[4];
}*p;
int main()
{
	int a1[5] = { 1, 2, 3, 4, 5 };
	int *ptr = (int *)(&a1 + 1);//&a+1是一个数组指针，但是数组指针是不能放进一个整形指针的，于是便强转wei整形指针，所以-1就只减掉了一个整型
	printf("%d,%d\n", *(a1 + 1), *(ptr - 1));
	printf("\n");
	//假设p的值为0x100000。则如下表达式的值分别是多少？
	//已知结构体Test类型的大小是20个字节


	p = (struct Test*)0x100000;
	printf("%p\n", p + 0x1);
	//p + 0x1就相当于p+1也就是地址跳过一，而p是结构体指针，那么+1便跳过的是一个结构体，而这个结构体是20个字节0x100000+20,将20转化为十六进制就是14，所以结果为0x100014
	printf("%p\n", (unsigned long)p + 0x1);
	//意思是将0x100000转化为整数形式1048576 再+1，得到的新的整数1048577再转化为十六进制0x100001打印
	printf("%p\n", (unsigned int*)p + 0x1);
	//将p，也就是0x100000强转成无符号整型，再跳过一个无符号整型，即4个字节得0x100004
	printf("\n");


	int a2[4] = { 1, 2, 3, 4 };
	//模拟数组内存分布情况01 00 00 00|02 00 00 00|03 00 00 00|04 00 00 00（注意该设备是小端存储，搞数据放在低地址处）
	int *ptr1 = (int*)(&a2 + 1);
	//&a2，取出的是整个数组的地址，&a2+1则跳过一个数组之后的地址，再转换成int*类型，而ptr1[-1]就是往后访问一个整型，那么便是4
	int *ptr2 = (int*)((int)a2 + 1);
	//a2作为数组名，此时是首元素地址，此时地址指针指向01，将地址强转成int型整数再+1，也就是相当于直接加一但是一旦转换成地址，此时转换成int*类型的地址，
	//就相当于地址往后多访问了一个字节，此时地址指针指向第一个00，然后，对int*类型的指针解引用访问4个字节，从第一个00往后访问四个字节，在通过小端存储方式，取出来打印就是02000000
	printf("%x\n%x\n", ptr1[-1], *ptr2);
	printf("\n");


	int a3[3][2] = { (0,1),(2,3),(4,5) };
	int *p;
	p = a3[0];
	printf("%d\n", p[0]);
	printf("\n");


	/*	int a4[5][5];
	int(*p)[4];
	p = a4;本来这里是行不通的，因为int(*)[4]----int(*)[5]两边类型不同，是不能赋值的，但现在这里将它强行赋值作为题目进行解答
	printf("%p,%d\n", &p[4][2] - &a4[4][2], &p[4][2] - &a4[4][2]);
	 __ __ __ __ __    __ __ __ __ __    __ __ __ __ __    __ __ __ __ __    __ __ __ __ __
	|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |
	 -- -- -- -- --    -- -- -- -- --    -- -- -- -- --    -- -- -- -- --    -- -- -- -- --
	^																^			   ^		
	这是p[0][0]														这是p[4][2]	   这是a4[4][2]
	有内存图可得，p[4][2]和a4[4][2]之间差了4个元素，又因为地址相减是两地址之间的元素个数，同时又因为p[4][2]地址小，a4[4][2]地址大，
	所以这个差值就是-4也就是说&p[4][2] - &a4[4][2]的结果是-4，那么%d打印的时候当然就是-4了，但是%p打印的时候情况又不一样了
	因为%p打印的是地址，但-4是个数，那么就会直接打印存储在系统中的-4，也就是-4的补码
	10000000000000000000000000000100 - 原码
	11111111111111111111111111111011 - 反码
	11111111111111111111111111111100 - 原码
	于是将原码当做地址直接打印出来，那么还需要转化为十六进制数，常理知1111为F，1100为12，固结果为
	%p - FFFFFFFC
	%d - -4
	*/
	return 0;
}