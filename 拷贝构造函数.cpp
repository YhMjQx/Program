//拷贝构造函数：
//功能：使用一个已经存在的对象来初始化一个新的同一类型的对象
//声明：只有一个参数并且参数为该类对象的引用
//如果类中没有说明拷贝构造函数，则系统会自动生成一个缺省复制构造函数，作为该类的公有成员

//注意，调用拷贝构造函数的前提是会产生内存的消耗或者开辟
//比如形参为类对象，实参也为类对象,这种情况就会调用拷贝构造函数
//但比如，形参为引用，实参为类对象，这种情况就不会调用拷贝构造函数
//因为，引用是不需要开辟新的空间的，他和实参类对象共用一块内存

#include"Class Text.h"

//下面就是拷贝构造函数调用的两种情况
void TextFun(const Text t){
	//这里会直接调用拷贝构造函数
	//此时需要用实参对象给形参初始化一个对象，所以要调用拷贝构造函数
}

void TextFun2(const Text& t){
	//这个形参是引用，所以不需要重新给形参开辟空间也不需要把实参拷贝赋值给形参
	//所以这个函数不调用拷贝构造函数
}

Text TextFun3(const Text& t){
	return t;
		//虽然这个函数的形参是引用，但是由于返回值是类，所以在返回的时候还是需要创建一个新的类对象
		//这里返回的对象不是引用的对象，而是新产生的临时对象
		//因此还是需要调用拷贝构造函数
}

const Text& TextFun4(const Text& t){
		//如果不想要返回的是const修饰的类，我们可以：
	//return const_cast<Text&>(t);
	return t;
}
int main(){
	Text t(39);
		////Text t1(t);// - Text t1 = t;调用系统提供的默认拷贝构造函数
				////用引用的话，是不会重新给形参分配内存的,且也不存在对象的拷贝
		////TextFun(t);//这里会调用拷贝构造函数

	//TextFun2(t);//这里并没有调用拷贝构造函数,//Text t2 = t;	这里是一定会调用拷贝构造函数的

	//TextFun3(t);
		////但如果没有对象来接收返回值的话，那么这个对象也就没有了存在的价值，所以就会立刻销毁
		////但是，就算接收成功，那么既然已经接收成功，这个临时对象同样没有存在价值，还是会被立刻销毁

	//t = TextFun3(t);
		////这里不仅调用了拷贝构造函数，还调用了等号运算符，说明这里是用一个对象赋值给另一个对象
		////此时用对象接收了这个临时对象，所以这个临时对象便有没有了存在的价值，因为已经赋值成功了，所以又被立刻销毁了

	//Text t2 = TextFun3(t);
		//这里虽然调用了拷贝构造函数，但是并没有调用等号运算符，说明这里是初始化，不是赋值操作
		//但是，在这里我们会发现打印输出和之前的不太一样了
		//是因为，现在用临时对象给t2初始化的时候是将这个临时对象变了个名字
		//就相当于把临时对象变为有名对象，名字就叫t2，所以此时这个所谓的临时对象不会立刻销毁
		//而是等main函数结束，生命周期（作用域）结束了之后再销毁

	//Text& t3 = TextFun3(t);
		//此时这个临时对象也不会立刻销毁，因为现在有一个t3的引用引用至这个临时对象
		//如果临时对象被销毁了，那么这个引用就是无效的引用

	const Text& t4 = TextFun4(t);
		//这里也没有立刻销毁对象，因为形参是引用，返回值也是引用
		//返回的引用会与形参共用同一块内存空间
		//而形参又引用至实参t，所以都不会立刻销毁
	cout << "......" << endl;
	return 0;
}